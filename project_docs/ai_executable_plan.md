Отлично. Я проанализировал ваши решения и интегрирую их в финальную версию плана. Это делает план еще более точным и устраняет оставшиеся неопределенности.

Вот обновленный и окончательный **AI-Executable Project Plan**.

---

# AI-Executable Project Plan: Сервис для поиска и привлечения ученых в проекты компаний (MVP v1.0)

## 1. Обзор Проекта
Проект представляет собой MVP онлайн-платформы (marketplace), соединяющей компании и индивидуальных ученых. Цель MVP — проверить основную гипотезу ценности: создание централизованной площадки для поиска и коммуникации. Основной сценарий: компания публикует проект, ученый подает заявку, стороны общаются в чате и фиксируют договоренности. Финансовые транзакции, командный функционал и форумы находятся вне рамок MVP.

**Технологические ограничения:**
*   **Бэкенд и База Данных:** Supabase (PostgreSQL, Auth, Storage, Realtime, Edge Functions).
*   **Развертывание:** Приложение должно быть полностью контейнеризировано с использованием Docker.

---

## 2. Детализированная Архитектура

### 2.1. Высокоуровневая Архитектура

```text
+------------------+       +-------------------------------+       +---------------------------------+
|   Пользователь   | ----> |     Frontend Приложение       | ----> |   Backend API (Edge Functions)  |
| (Веб-браузер)    |       | (React + TypeScript)          |       | (Deno + TypeScript)             |
+------------------+       | (Запущено в Docker контейнере)|       +---------------------------------+
                         +-------------------------------+                     | (HTTPS/REST, WebSocket)
                                                                               |
                                                                               v
                         +--------------------------------------------------------------------------------+
                         |                                 Supabase Cloud Platform                         |
                         |--------------------------------------------------------------------------------|
                         |  Аутентификация |  База Данных   |    Хранилище    |  Realtime   |   Functions  |
                         |   (Auth)        |  (PostgreSQL)  | (File Storage)  | (WebSocket) | (Deno Runtime)|
                         +--------------------------------------------------------------------------------+
```

### 2.2. Логическая Архитектура (Структура каталогов)

*   **Frontend (/frontend):** `/src` -> `/app`, `/components`, `/features` (auth, projects, etc.), `/hooks`, `/lib`, `/services`, `/store`, `/types`.
*   **Backend (/supabase):** `/functions` (_shared, projects, etc.), `/migrations`.

### 2.3. Физическая/Развертываемая Архитектура

Развертывание через CI/CD (GitHub Actions) в Docker-контейнеры. Frontend-контейнер разворачивается на хостинге (Vercel, DigitalOcean App Platform), Supabase используется как управляемый облачный сервис.

### 2.4. Технологический Стек

*   **Frontend:** React 18, TypeScript, Vite, TailwindCSS, Zustand, React Query, Zod.
*   **Backend:** Supabase Edge Functions (Deno, TypeScript), Deno `oak`.
*   **База Данных:** PostgreSQL.
*   **Инфраструктура:** Docker, Docker Compose, GitHub Actions.

### 2.5. Модели Данных (Схема БД)

```text
Table: users (управляется Supabase Auth, дополняется публичным профилем)
  id (uuid, PK, FK to auth.users.id)
  email (varchar, from auth.users)
  role (enum: 'company_user', 'researcher', 'admin')

Table: company_profiles
  id (uuid, PK, FK to users.id)
  name (varchar), description (text), website (varchar)

Table: researcher_profiles
  id (uuid, PK, FK to users.id)
  full_name (varchar), scientific_field (varchar)
  skills (text[]), portfolio_links (text[]), publication_links (text[])
  orcid_id (varchar, nullable)

Table: projects
  id (uuid, PK), company_id (uuid, FK to company_profiles.id)
  title (varchar), description (text), budget_text (varchar)
  status (enum: 'open', 'in_progress', 'completed', 'closed')

Table: applications
  id (uuid, PK), project_id (uuid, FK to projects.id)
  researcher_id (uuid, FK to researcher_profiles.id)
  cover_letter (text), status (enum: 'submitted', 'viewed', 'rejected', 'accepted')

Table: chats
  id (uuid, PK), application_id (uuid, FK to applications.id, unique)

Table: chat_messages
  id (uuid, PK), chat_id (uuid, FK to chats.id)
  sender_id (uuid, FK to users.id), message_text (text)

Table: reviews
  id (uuid, PK), project_id (uuid, FK to projects.id)
  author_id (uuid, FK to users.id), recipient_id (uuid, FK to users.id)
  rating (int, 1-5), text (text)
```

### 2.6. Вопросы Безопасности
Основной механизм — политики **Row Level Security (RLS)** в PostgreSQL, управляемые Supabase, в сочетании с проверкой JWT-токенов на уровне API (Edge Functions).

### 2.7. API и Протоколы Взаимодействия
HTTPS/REST для основного API, WebSocket (через Supabase Realtime) для чатов. Все запросы защищены JWT-авторизацией.

---

## 3. Детализированный Перечень Задач

### 3.1. Фаза 1: Инициализация и Настройка

>>>ЗАДАЧА<<< 1.1. Настройка проекта и репозитория
*   **Статус:** Ожидание
*   **Зависимости:** Нет
*   **Приоритет:** Высокий
*   **Ответственный:** AI-DevOps-Agent
*   **Подробнейшее Описание:** Создать Git-репозиторий, инициализировать Vite (React+TS) проект в `/frontend` и Supabase проект в корне. Настроить базовую структуру папок, ESLint, Prettier.
*   **Критерии Приемки:** Репозиторий создан и структурирован. Команды `lint` и `format` работают.
<<<Окончание задачи>>> 1.1

>>>ЗАДАЧА<<< 1.2. Настройка Supabase и Docker-окружения
*   **Статус:** Ожидание
*   **Зависимости:** 1.1
*   **Приоритет:** Высокий
*   **Ответственный:** AI-DevOps-Agent
*   **Подробнейшее Описание:** Связать локальный Supabase с облачным проектом. Создать `docker-compose.yml` для запуска локального инстанса Supabase и dev-сервера фронтенда. Создать `Dockerfile` для production-сборки фронтенда.
*   **Критерии Приемки:** Команда `docker-compose up` успешно запускает локальное окружение.
<<<Окончание задачи>>> 1.2

>>>ЗАДАЧА<<< 1.3. Создание начальной схемы БД и RLS политик
*   **Статус:** Ожидание
*   **Зависимости:** 1.2
*   **Приоритет:** Высокий
*   **Ответственный:** AI-Backend-Agent
*   **Подробнейшее Описание:** Создать SQL-миграцию в `supabase/migrations/` для всех таблиц, перечисленных в разделе 2.5. Для каждой таблицы включить RLS и создать базовые политики, разрешающие пользователям управлять только своими данными.
*   **Критерии Приемки:** Команда `supabase db reset` успешно применяет миграцию. RLS включен для всех таблиц.
<<<Окончание задачи>>> 1.3

### 3.2. Фаза 2: Аутентификация и Профили

>>>ЗАДАЧА<<< 2.1. Frontend: Реализация UI и логики для регистрации и входа
*   **Статус:** Ожидание
*   **Зависимости:** 1.3
*   **Приоритет:** Высокий
*   **Ответственный:** AI-Frontend-Agent
*   **Подробнейшее Описание:** Создать страницы `/register` и `/login`. Форма регистрации должна содержать поля Email, Пароль и выбор роли ("Компания" или "Ученый"). Использовать `supabase.auth.signUp()` и `supabase.auth.signInWithPassword()`. После входа сохранять сессию в Zustand store.
*   **Критерии Приемки:** Пользователь может зарегистрироваться и войти. Сессия сохраняется при перезагрузке страницы.
<<<Окончание задачи>>> 2.1

>>>ЗАДАЧА<<< 2.2. Backend: Создание профилей после регистрации
*   **Статус:** Ожидание
*   **Зависимости:** 1.3
*   **Приоритет:** Высокий
*   **Ответственный:** AI-Backend-Agent
*   **Подробнейшее Описание:** Создать триггер в PostgreSQL на таблице `auth.users`. Триггер должен вызывать функцию, которая на основе `raw_user_meta_data.role` (переданного при регистрации) создает запись в `public.users` и соответствующую пустую запись в `public.company_profiles` или `public.researcher_profiles`.
*   **Критерии Приемки:** После регистрации нового пользователя автоматически создаются связанные записи в публичных таблицах профилей.
<<<Окончание задачи>>> 2.2

>>>ЗАДАЧА<<< 2.3. Frontend: Реализация UI для редактирования профилей
*   **Статус:** Ожидание
*   **Зависимости:** 2.1, 2.2
*   **Приоритет:** Высокий
*   **Ответственный:** AI-Frontend-Agent
*   **Подробнейшее Описание:**
    *   **Логика работы:** Создать страницу `/profile/edit`. В зависимости от роли залогиненного пользователя, отображать соответствующую форму для редактирования.
        *   **Форма Компании:** Поля для `name`, `description`, `website`.
        *   **Форма Ученого:** Поля для `full_name`, `scientific_field`, `skills` (ввод тегов), `portfolio_links` (список URL), `publication_links` (список URL), `orcid_id` (текстовое поле).
    *   **Цель задачи:** Дать пользователям возможность заполнять и обновлять свои профили.
    *   **Входные данные:** Текущие данные профиля пользователя.
    *   **Выходные данные/Ожидаемый результат:** Формы, которые сохраняют обновленные данные в Supabase.
*   **Критерии Приемки:**
    *   Пользователь видит форму, соответствующую его роли.
    *   Данные успешно сохраняются при отправке формы.
    *   Обновленные данные отображаются на странице просмотра профиля.
*   **Технические Детали/Инструкции:** Использовать `react-hook-form` и `zod` для валидации. Для сохранения использовать `supabase.from('...').update(...)`. Интеграция с внешними сервисами через OAuth на данном этапе не реализуется, все поля являются текстовыми.
*   **Связанные Артефакты:** 2.5. Модели Данных (company_profiles, researcher_profiles).
<<<Окончание задачи>>> 2.3

Понял. Генерирую полный и детализированный список задач для Фаз 3, 4 и 5 в требуемом формате.

---

### 3.3. Фаза 3: Функционал Проектов

>>>ЗАДАЧА<<< 3.1. Backend: CRUD API для Проектов
*   **Статус:** Ожидание
*   **Зависимости:** 1.3, 2.2
*   **Приоритет:** Высокий
*   **Ответственный:** AI-Backend-Agent
*   **Подробнейшее Описание:**
    *   **Логика работы:** Создать Supabase Edge Function в `supabase/functions/projects/index.ts`. Эта функция должна обрабатывать HTTP-запросы для управления проектами. Использовать роутер (например, Deno `oak`) для обработки следующих маршрутов:
        *   `GET /`: Получение списка всех *публичных* проектов с пагинацией.
        *   `GET /my`: Получение списка проектов, принадлежащих аутентифицированной компании.
        *   `POST /`: Создание нового проекта. Функция должна извлекать `company_id` из JWT-токена пользователя и присваивать его новому проекту.
        *   `GET /:id`: Получение информации о конкретном проекте.
        *   `PATCH /:id`: Обновление информации о проекте.
        *   `DELETE /:id`: Удаление проекта.
    *   **Цель задачи:** Предоставить API для полного жизненного цикла управления проектами.
    *   **Входные данные:** HTTP-запросы с JWT-токеном. Тело запроса для `POST` и `PATCH` содержит данные проекта (title, description и т.д.).
    *   **Выходные данные/Ожидаемый результат:** JSON-ответы с данными проекта(ов) или статусом успеха/ошибки.
*   **Критерии Приемки:**
    *   Все эндпоинты работают и возвращают корректные HTTP-статусы (200, 201, 400, 401, 403, 404).
    *   Запросы без JWT-токена к защищенным маршрутам (все, кроме `GET /` и `GET /:id`) получают 401.
    *   Пользователь с ролью `company_user` может создавать/изменять/удалять только проекты своей компании (проверяется RLS-политиками, которые должны быть дополнены).
    *   Пользователь с ролью `researcher` не может создавать/изменять/удалять проекты.
*   **Технические Детали/Инструкции:**
    *   Создать RLS-политику, разрешающую `SELECT` для всех пользователей на публичные проекты (`type = 'public'`).
    *   Создать RLS-политику, разрешающую `INSERT`, `UPDATE`, `DELETE` только для пользователей, чей `id` совпадает с `company_profiles.id`, на который ссылается `projects.company_id`.
    *   Валидировать входящие данные с помощью Zod.
*   **Связанные Артефакты:** 2.5. Модели Данных (projects), 2.7. API.
<<<Окончание задачи>>> 3.1

>>>ЗАДАЧА<<< 3.2. Frontend: UI для списка и просмотра проектов
*   **Статус:** Ожидание
*   **Зависимости:** 3.1
*   **Приоритет:** Высокий
*   **Ответственный:** AI-Frontend-Agent
*   **Подробнейшее Описание:**
    *   **Логика работы:**
        1.  Создать страницу `/projects`, которая будет отображать список всех публичных проектов.
        2.  Реализовать компонент `ProjectCard` для отображения краткой информации о проекте (название, компания, бюджет).
        3.  Использовать `useQuery` из React Query для запроса данных с эндпоинта `GET /projects`.
        4.  Реализовать пагинацию или "бесконечную прокрутку" для списка.
        5.  Создать страницу `/projects/:id` для детального просмотра проекта.
        6.  При клике на карточку проекта на странице `/projects`, осуществлять переход на `/projects/:id`.
    *   **Цель задачи:** Дать возможность ученым находить и просматривать интересующие их проекты.
    *   **Входные данные:** Данные от API `GET /projects`.
    *   **Выходные данные/Ожидаемый результат:** Интерактивные страницы со списком и детальным видом проектов.
*   **Критерии Приемки:**
    *   Страница `/projects` корректно отображает список проектов, полученных от API.
    *   Пагинация работает.
    *   Страница `/projects/:id` отображает полную информацию о выбранном проекте.
    *   Страницы адаптированы для мобильных устройств.
*   **Технические Детали/Инструкции:** Использовать `react-router-dom` для роутинга. React Query для управления серверным состоянием. TailwindCSS для стилизации.
*   **Связанные Артефакты:** 2.2. Логическая Архитектура (Frontend), 3.1.
<<<Окончание задачи>>> 3.2

>>>ЗАДАЧА<<< 3.3. Frontend: UI для управления проектами компании
*   **Статус:** Ожидание
*   **Зависимости:** 3.1
*   **Приоритет:** Высокий
*   **Ответственный:** AI-Frontend-Agent
*   **Подробнейшее Описание:**
    *   **Логика работы:**
        1.  Создать защищенную страницу `/dashboard/projects` для пользователей с ролью `company_user`.
        2.  На этой странице отображать список проектов, принадлежащих компании (запрос к `GET /projects/my`).
        3.  Добавить кнопку "Создать проект", которая ведет на страницу `/dashboard/projects/new`.
        4.  Создать форму на `/dashboard/projects/new` для создания проекта (поля: title, description, budget_text, type).
        5.  Реализовать страницу редактирования `/dashboard/projects/:id/edit`.
        6.  В списке проектов компании добавить кнопки для редактирования, удаления и изменения статуса проекта (например, "Закрыть проект").
    *   **Цель задачи:** Предоставить компаниям полный инструментарий для управления своими проектами.
    *   **Входные данные:** JWT-токен пользователя компании.
    *   **Выходные данные/Ожидаемый результат:** Панель управления проектами для компаний.
*   **Критерии Приемки:**
    *   Доступ к `/dashboard/*` есть только у залогиненных пользователей с ролью `company_user`.
    *   Компания видит только свои проекты.
    *   Форма создания/редактирования успешно отправляет данные на API.
    *   Проекты успешно удаляются.
*   **Технические Детали/Инструкции:** Использовать `react-hook-form` и Zod для форм. `useMutation` из React Query для операций создания/обновления/удаления с автоматической инвалидацией кеша списка проектов.
*   **Связанные Артефакты:** 2.2. Логическая Архитектура (Frontend), 3.1.
<<<Окончание задачи>>> 3.3

### 3.4. Фаза 4: Заявки и Коммуникация

>>>ЗАДАЧА<<< 4.1. Backend: CRUD API для Заявок
*   **Статус:** Ожидание
*   **Зависимости:** 3.1
*   **Приоритет:** Высокий
*   **Ответственный:** AI-Backend-Agent
*   **Подробнейшее Описание:**
    *   **Логика работы:** Создать Edge Function `applications`.
        *   `POST /`: Создание новой заявки. Пользователь должен быть `researcher`. Функция должна принимать `project_id` и `cover_letter`. **Критически важно:** после успешного создания заявки, функция должна в той же транзакции создать запись в таблице `chats`, связанную с новой `application_id`.
        *   `GET /my`: Получение списка заявок, поданных аутентифицированным `researcher`.
        *   `GET /project/:projectId`: Получение списка заявок на конкретный проект. Доступно только для владельца проекта.
        *   `PATCH /:id`: Обновление статуса заявки (`viewed`, `rejected`, `accepted`). Доступно только для владельца проекта.
    *   **Цель задачи:** Обеспечить API для подачи и управления заявками.
*   **Критерии Приемки:**
    *   Ученый может подать заявку на проект.
    *   Компания может просматривать заявки на свои проекты и менять их статус.
    *   Ученый может видеть статус своих заявок.
    *   При создании заявки автоматически создается чат.
    *   Все операции защищены RLS-политиками.
*   **Технические Детали/Инструкции:** Создать RLS-политики для таблицы `applications`. Использовать RPC-функцию в PostgreSQL для транзакционного создания заявки и чата.
*   **Связанные Артефакты:** 2.5. Модели Данных (applications, chats).
<<<Окончание задачи>>> 4.1

>>>ЗАДАЧА<<< 4.2. Frontend: Реализация подачи заявки на проект
*   **Статус:** Ожидание
*   **Зависимости:** 3.2, 4.1
*   **Приоритет:** Высокий
*   **Ответственный:** AI-Frontend-Agent
*   **Подробнейшее Описание:**
    *   **Логика работы:**
        1.  На странице детального просмотра проекта (`/projects/:id`) добавить кнопку "Подать заявку".
        2.  Кнопка доступна только для залогиненных пользователей с ролью `researcher`, которые еще не подавали заявку на этот проект.
        3.  При клике открывается модальное окно с полем `textarea` для сопроводительного письма (`cover_letter`) и кнопкой "Отправить".
        4.  При отправке используется `useMutation` для вызова API `POST /applications`.
    *   **Цель задачи:** Дать ученым возможность откликаться на проекты.
*   **Критерии Приемки:**
    *   Кнопка "Подать заявку" отображается/скрывается в зависимости от статуса пользователя.
    *   Заявка успешно отправляется через модальное окно.
    *   После успешной отправки пользователь получает уведомление, и кнопка "Подать заявку" становится неактивной.
*   **Технические Детали/Инструкции:** Использовать компонент модального окна из UI-кита.
*   **Связанные Артефакты:** 3.2, 4.1.
<<<Окончание задачи>>> 4.2

>>>ЗАДАЧА<<< 4.3. Backend: Настройка Realtime для Чатов
*   **Статус:** Ожидание
*   **Зависимости:** 4.1
*   **Приоритет:** Высокий
*   **Ответственный:** AI-Backend-Agent
*   **Подробнейшее Описание:**
    *   **Логика работы:**
        1.  В настройках проекта Supabase включить Realtime для таблицы `chat_messages`.
        2.  Создать RLS-политики для таблицы `chat_messages`, которые разрешают `SELECT` и `INSERT` только для участников чата. Участники чата — это `researcher`, подавший заявку, и `user` из компании-владельца проекта. Эту информацию можно получить через `JOIN` с таблицами `chats`, `applications`, `projects`.
    *   **Цель задачи:** Подготовить бэкенд для функционирования real-time чата.
*   **Критерии Приемки:**
    *   Realtime для `chat_messages` включен.
    *   RLS-политики не позволяют пользователям читать или писать в чужие чаты.
*   **Технические Детали/Инструкции:**
    *   Пример RLS для `SELECT`:
        ```sql
        CREATE POLICY "Allow read for chat participants" ON chat_messages FOR SELECT USING (
          auth.uid() IN (
            SELECT a.researcher_id FROM applications a JOIN chats c ON c.application_id = a.id WHERE c.id = chat_id
            UNION
            SELECT p.company_id FROM projects p JOIN applications a ON a.project_id = p.id JOIN chats c ON c.application_id = a.id WHERE c.id = chat_id
          )
        );
        ```
*   **Связанные Артефакты:** 2.5. Модели Данных (chat_messages).
<<<Окончание задачи>>> 4.3

>>>ЗАДАЧА<<< 4.4. Frontend: Реализация UI Чата
*   **Статус:** Ожидание
*   **Зависимости:** 4.3
*   **Приоритет:** Высокий
*   **Ответственный:** AI-Frontend-Agent
*   **Подробнейшее Описание:**
    *   **Логика работы:**
        1.  Создать страницу `/dashboard/chat/:applicationId`.
        2.  На странице реализовать классический интерфейс чата: слева список сообщений, внизу поле для ввода и кнопка "Отправить".
        3.  Использовать `supabase.channel().on().subscribe()` для подписки на новые сообщения в таблице `chat_messages`, фильтруя по `chat_id`.
        4.  При получении нового сообщения добавлять его в список.
        5.  При отправке сообщения использовать `supabase.from('chat_messages').insert(...)`.
    *   **Цель задачи:** Обеспечить прямую коммуникацию между компанией и кандидатом.
*   **Критерии Приемки:**
    *   Пользователи видят историю сообщений в чате.
    *   Новые сообщения появляются в реальном времени без перезагрузки страницы.
    *   Пользователи могут отправлять сообщения.
    *   Доступ к чату есть только у участников (компания и кандидат).
*   **Технические Детали/Инструкции:** Использовать хук `useEffect` для подписки и отписки от канала Supabase Realtime.
*   **Связанные Артефакты:** 4.3.
<<<Окончание задачи>>> 4.4

### 3.5. Фаза 5: Отзывы и Завершение

>>>ЗАДАЧА<<< 5.1. Backend: API для Отзывов
*   **Статус:** Ожидание
*   **Зависимости:** 3.1
*   **Приоритет:** Средний
*   **Ответственный:** AI-Backend-Agent
*   **Подробнейшее Описание:**
    *   **Логика работы:** Создать Edge Function `reviews`.
        *   `POST /`: Создание нового отзыва. Функция должна проверять, что `project.status` равен `'completed'`, и что `author_id` является либо владельцем проекта, либо принятым кандидатом. Также нужно проверять, что пользователь еще не оставлял отзыв на этот проект.
        *   `GET /user/:userId`: Получение всех отзывов, оставленных о конкретном пользователе.
    *   **Цель задачи:** Позволить пользователям оценивать друг друга после завершения работы.
*   **Критерии Приемки:**
    *   Отзыв можно оставить только на завершенный проект.
    *   Отзыв могут оставить только участники проекта.
    *   Нельзя оставить больше одного отзыва на проект от одного автора.
*   **Технические Детали/Инструкции:** Вся логика проверок должна быть реализована внутри Edge Function перед вставкой данных в БД.
*   **Связанные Артефакты:** 2.5. Модели Данных (reviews).
<<<Окончание задачи>>> 5.1

>>>ЗАДАЧА<<< 5.2. Frontend: UI для системы отзывов
*   **Статус:** Ожидание
*   **Зависимости:** 5.1
*   **Приоритет:** Средний
*   **Ответственный:** AI-Frontend-Agent
*   **Подробнейшее Описание:**
    *   **Логика работы:**
        1.  На странице проекта, если его статус `'completed'`, отображать для участников кнопку "Оставить отзыв".
        2.  Реализовать форму для оставления отзыва (рейтинг 1-5 звезд и текстовое поле).
        3.  На страницах публичных профилей пользователей (`/users/:id` и `/companies/:id`) отображать блок с полученными отзывами и средним рейтингом.
    *   **Цель задачи:** Сделать систему репутации видимой для пользователей.
*   **Критерии Приемки:**
    *   Пользователи могут оставлять отзывы.
    *   Отзывы и средний рейтинг отображаются на страницах профилей.
*   **Технические Детали/Инструкции:** Использовать UI-компонент для отображения звезд рейтинга.
*   **Связанные Артефакты:** 5.1.
<<<Окончание задачи>>> 5.2

>>>ЗАДАЧА<<< 5.3. DevOps: Настройка CI/CD
*   **Статус:** Ожидание
*   **Зависимости:** 1.2
*   **Приоритет:** Высокий
*   **Ответственный:** AI-DevOps-Agent
*   **Подробнейшее Описание:**
    *   **Логика работы:** Создать workflow в `.github/workflows/deploy.yml`.
        1.  Триггер: push в ветку `main`.
        2.  Шаг 1: Checkout кода.
        3.  Шаг 2: Установка зависимостей (Node.js, Supabase CLI).
        4.  Шаг 3: Линтинг и тесты (если есть).
        5.  Шаг 4: Развертывание миграций БД (`supabase db push`).
        6.  Шаг 5: Развертывание Edge Functions (`supabase functions deploy`).
        7.  Шаг 6: Сборка Docker-образа для фронтенда (`docker build`).
        8.  Шаг 7: Push Docker-образа в реестр (GitHub Container Registry).
        9.  Шаг 8: (Опционально, зависит от хостинга) Триггер для развертывания нового образа на хостинге через webhook или CLI.
    *   **Цель задачи:** Автоматизировать процесс сборки, тестирования и развертывания приложения.
*   **Критерии Приемки:**
    *   Push в `main` автоматически запускает пайплайн.
    *   Пайплайн успешно завершается.
    *   Изменения в коде (миграции, функции, фронтенд) отражаются на production-среде.
*   **Технические Детали/Инструкции:** Использовать `actions/checkout@v3`, `supabase/cli@v1`. Хранить `SUPABASE_ACCESS_TOKEN` и другие секреты в GitHub Secrets.
*   **Связанные Артефакты:** 2.3. Физическая/Развертываемая Архитектура.
<<<Окончание задачи>>> 5.3

---

## 4. План Разработки

### 4.1. Общие Фазы и Вехи

*   **Фаза 1: Инициализация и Настройка (0.5 недели)**
    *   *Веха 1:* Проект инициализирован, разворачивается локально, схема БД создана.
*   **Фаза 2: Аутентификация и Профили (1 неделя)**
    *   *Веха 2:* Пользователи могут регистрироваться, входить и редактировать свои профили.
*   **Фаза 3: Функционал Проектов (1.5 недели)**
    *   *Веха 3:* Реализован полный CRUD для проектов.
*   **Фаза 4: Заявки и Коммуникация (2 недели)**
    *   *Веха 4:* Работает система подачи заявок и real-time чат.
*   **Фаза 5: Отзывы и CI/CD (1 неделя)**
    *   *Веха 5 (Финальная):* Реализована система отзывов, настроен CI/CD, MVP развернут.

### 4.2. Последовательность Выполнения Задач

1.  **Неделя 1 (Инициализация):**
    *   Выполнить задачи `1.1`, `1.2`, `1.3`.
2.  **Неделя 2 (Аутентификация):**
    *   (Параллельно) `2.1` (Frontend) и `2.2` (Backend).
    *   (После `2.1` и `2.2`) `2.3` (Frontend).
3.  **Недели 3-7 (Core-функционал):**
    *   Последовательная работа над фазами 3, 4, 5 с параллельной разработкой Backend и Frontend, где это возможно.

---

## 5. Итоговые Решения и Принятые Риски

На основе анализа и ваших уточнений были приняты следующие ключевые решения для MVP:

1.  **Упрощенная интеграция с внешними профилями:** Принято решение на этапе MVP отказаться от сложной OAuth-интеграции для ORCID/Google Scholar. Вместо этого будут реализованы простые текстовые поля для ввода пользователями ссылок и идентификаторов. Это значительно ускоряет разработку модуля профилей.

2.  **Принятый риск Vendor Lock-in:** Принято решение использовать Supabase как основную платформу, осознавая стратегический риск сильной зависимости от одного провайдера. Скорость разработки для MVP является приоритетом над гибкостью миграции в будущем.

3.  **Отказ от Staging-окружения:** Принято решение не создавать отдельное промежуточное (staging) окружение для MVP с целью экономии ресурсов и времени. Тестирование будет проводиться в локальном Docker-окружении и непосредственно на production-площадке после развертывания.